<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>ZheGeWangYeDaBuKai</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="ZheGeWangYeDaBuKai">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="ZheGeWangYeDaBuKai">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZheGeWangYeDaBuKai">
  
    <link rel="alternate" href="/atom.xml" title="ZheGeWangYeDaBuKai" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ZheGeWangYeDaBuKai</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JSON" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/15/JSON/" class="article-date">
  <time datetime="2018-08-15T09:22:36.000Z" itemprop="datePublished">2018-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/15/JSON/">JSON</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>JSON.</p>
</blockquote>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>简单的加法运算<br>占位符：&amp;&amp;&amp;amount&amp;&amp;&amp;<br>form表单 一点击就刷新<br>iframe也可以实现，但现在已淘汰。可以用iframe来承载成功或失败，不用刷新页面<br>解决办法：<br>a、img、script、link都可以发请求，没有==不能post，只会get。<br>onload/onerror，成功，失败</p>
<p>Diaspora</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/15/JSON/" data-id="cjkxghrjx0003ewkw4a99a5hr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-DOM事件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/14/DOM事件/" class="article-date">
  <time datetime="2018-08-14T03:30:03.000Z" itemprop="datePublished">2018-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/14/DOM事件/">DOM事件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>DOM事件。</p>
</blockquote>
<h1 id="如何做操点击别处关闭浮层？"><a href="#如何做操点击别处关闭浮层？" class="headerlink" title="如何做操点击别处关闭浮层？"></a>如何做操点击别处关闭浮层？</h1><p>第一阶段：<br>stopPropagation以为是最终解决方案，如果在button中加一个checkbox，在IE8中会出现bug，点不了checkbox，点击事件不管用。<br>并且如果页面中存在很多点击方案，那就需要监听多次，浪费内存。<br>(<a href="http://js.jirengu.com/honahuziju/1/edit?html,js,output" target="_blank" rel="noopener">http://js.jirengu.com/honahuziju/1/edit?html,js,output</a>)<br>第二阶段：节省内存的方案<br>如果在checkbox的父元素的任一层添加阻止默认事件，那么就不能check。<br><code>$(&#39;#wrapper&#39;).on(&#39;click&#39;,false)</code><br>存在bug，阻止了checkbox。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#clickMe&apos;).on(&apos;click&apos;,function()&#123;</span><br><span class="line">  $(&apos;#popover&apos;).show()</span><br><span class="line">  $(document).one(&apos;click&apos;,function()&#123;</span><br><span class="line">  $(&apos;#popover&apos;).hide()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(&apos;#wrapper&apos;).on(&apos;click&apos;,function(e)&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  e.stopPropagation()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>最终是这个，在点击clickMe后再添加document的监听事件，并且是一次的one，如果一直监听的话，只要一点击就监听，会造成内存的浪费。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#clickMe&apos;).on(&apos;click&apos;,function()&#123;</span><br><span class="line">  $(&apos;#popover&apos;).show()</span><br><span class="line">  $(document).one(&apos;click&apos;,function()&#123;</span><br><span class="line">  $(&apos;#popover&apos;).hide()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这里，在点击一次后，把popover展示出来，并添加一个document监听事件函数，立即执行。所以不会展示浮层。<br>两种解决方法：<br>1，阻止事件监听，stopPropagation<br>2，计时器，一层一层冒泡，通知，完了发现计时器没有执行，就执行，添加fn2，但不会执行，因为通知过程已经完了<br>，下次点击才会执行。</p>
<h1 id="轮播bug"><a href="#轮播bug" class="headerlink" title="轮播bug"></a>轮播bug</h1><p>切出去之后过来会出现bug，一下把切出去为播放的页面一次展示出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&apos;visibilitychange&apos;,function()&#123;</span><br><span class="line">    if(document.hidden)&#123;</span><br><span class="line">       window.clearInterval(timer)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        timer = setInterval(function()&#123;</span><br><span class="line">            makeLeave(getImage(n))</span><br><span class="line">            .one(&apos;transitionend&apos;,function(e)&#123;</span><br><span class="line">                makeEnter($(e.currentTarget))</span><br><span class="line">            &#125;)</span><br><span class="line">            makeCurrent(getImage(n+1))</span><br><span class="line">            n += 1</span><br><span class="line">        &#125;,1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="不一样的轮播-新方案"><a href="#不一样的轮播-新方案" class="headerlink" title="不一样的轮播-新方案"></a>不一样的轮播-新方案</h2><p>如果hide后show没有反应，那么你就offset一下。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/14/DOM事件/" data-id="cjkxghrjr0002ewkw6n64zvl9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jQuery" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/10/jQuery/" class="article-date">
  <time datetime="2018-08-10T06:15:28.000Z" itemprop="datePublished">2018-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/10/jQuery/">jQuery</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>jQuery,使用最广泛的JavaScript函数库。首先，它是一个DOM操作工具，使得操作DOM对象变得容易；还统一了不同浏览器的API接口，是所有的代码在不同浏览器中都可运行，不必担心差异。</p>
</blockquote>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>如果我想实现一个方法，但DOM和浏览器又没有提供这个API，当进行项目时又会经常使用这个方法，简单的方法就是我把这中方法的代码写出来，放到电脑上建一个函数，当需要使用时，我就把这个函数添加进去再进行调用就行了。<br>问题：但是每次使用我都得进行添加函数、调用函数这些步骤，显得冗余？<br>设想另一种方法，在原型与原型链中，知道，浏览器和JS是把这些经常能够实现某种目的的函数的API都是直接存在原型prototype上，用到的时候直接调用很方便。如果我也把自己经常使用的函数存储到DOM或者浏览器的prototype上，我使用的时候直接调用岂不是很方便(怎么没有别人发现这么方便简介的办法？有坑？)<br>这样就会引起另一个问题（一个问题引起另一个问题bug？）：如果别人已经在prototype上写入了一个函数，那么你又写入了一个函数，那到底谁写的算呀，并不是先入为主，后来的总会覆盖先来的。又或者你写的把浏览器或者DOM的prototype给覆盖掉了（GG），无休止的写下去，岂不是显得（咦，贵圈真乱）？？<br><a href="https://www.zhihu.com/question/26924011" target="_blank" rel="noopener">为什么不要直接在Object.prototype上定义方法？(JavaScript):</a><br>总结下来就是：做一个项目的时候，你改了一个prototype，你同事也改了一个，最后bug你都不知道从哪找，找到你都感到改bug改的头疼。<br>退而求其次，那我就目标远大一些，造福一方人嘛，JS和浏览器有它的node接口，我也写一个我自己的接口如何？这个，可能有点难~~~<br><a href="https://juejin.im/entry/5708de8a7db2a20051cfaf8d" target="_blank" rel="noopener">设计更好的 JavaScript API：</a><br>那么就没有人提前发现这个问题吗，有的【jQuery】。<br>暂定</p>
<h1 id="例"><a href="#例" class="headerlink" title="例"></a>例</h1><h2 id="实现两个函数getSiblings和addClass"><a href="#实现两个函数getSiblings和addClass" class="headerlink" title="实现两个函数getSiblings和addClass"></a>实现两个函数getSiblings和addClass</h2><p>简单写法：<code>ul&gt;li[id=item$]{选项$}*5</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li id=&quot;item1&quot;&gt;选项1&lt;/li&gt;</span><br><span class="line">  &lt;li id=&quot;item2&quot;&gt;选项2&lt;/li&gt;</span><br><span class="line">  &lt;li id=&quot;item3&quot;&gt;选项3&lt;/li&gt;</span><br><span class="line">  &lt;li id=&quot;item4&quot;&gt;选项4&lt;/li&gt;</span><br><span class="line">  &lt;li id=&quot;item5&quot;&gt;选项5&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="获取一个节点的所有兄弟姐妹"><a href="#获取一个节点的所有兄弟姐妹" class="headerlink" title="获取一个节点的所有兄弟姐妹"></a>获取一个节点的所有兄弟姐妹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getSlibings(node)&#123;</span><br><span class="line">  var allChildren = node.parentNode.children;</span><br><span class="line">  var arr = &#123;length:0&#125;</span><br><span class="line">  for (let i = 0; i &lt; allChildren.length; i++) &#123;</span><br><span class="line">    if (allChildren[i] !== node) &#123;</span><br><span class="line">      arr[arr.length] = allChildren[i]  </span><br><span class="line">      arr.length += 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点：arr[arr.length] = allChildren[i] 之所以不用arr[i] = allChildren[i],是应为 arr[i] 是因为可能会跳过，导致 arr 的 key 会不完整；使用 arr[arr.length] 可以很好的给伪数组添加完整的数字 key 。</p>
<h3 id="添加删除class"><a href="#添加删除class" class="headerlink" title="添加删除class"></a>添加删除class</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function addClass(node,classes)&#123;</span><br><span class="line">    for(let key in classes)&#123;</span><br><span class="line">        var value = classes[key]</span><br><span class="line">        if(value)&#123;</span><br><span class="line">            node.classList.add(key)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            node.classList.remove(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>对于以上两个函数可以取一个名字，自己用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.czdom = &#123;&#125;</span><br><span class="line">czdom.getSlibings = getSlibings</span><br><span class="line">czdom.addClass = addClass</span><br><span class="line">//想用的话只需</span><br><span class="line">czdom.getSlibings(item3)</span><br><span class="line">czdom.getSlibings(item3,&#123;a:xx,b:xx,c:xx&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="也可以"><a href="#也可以" class="headerlink" title="也可以"></a>也可以</h2><p>在prototype上添加方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node.prototype.getSiblings = function() &#123;</span><br><span class="line">  var allChildren = this.parentNode.children  //使用 this</span><br><span class="line">  var arr = &#123;length:0&#125;</span><br><span class="line">  for (let i = 0; i &lt; allChildren.length; i++) &#123;</span><br><span class="line">    if (allChildren[i] !== this) &#123;</span><br><span class="line">      arr[arr.length] = allChildren[i] </span><br><span class="line">      arr.length += 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node.prototype.addClass = function(classes) &#123;</span><br><span class="line">    for (let key in classes) &#123;</span><br><span class="line">    var value = classes[key]</span><br><span class="line">    var methodName = value ? &apos;add&apos; : &apos;remove&apos;</span><br><span class="line">    this.classList[methodName](key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者新的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">window.Node2 = function(node) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        getSilings: function() &#123;</span><br><span class="line">          var allChildren = node.parentNode.children </span><br><span class="line">          var arr = &#123;length:0&#125;</span><br><span class="line">          for (let i = 0; i &lt; allChildren.length; i++) &#123;</span><br><span class="line">            if (allChildren[i] !== node) &#123;</span><br><span class="line">              arr[arr.length] = allChildren[i] </span><br><span class="line">              arr.length += 1</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; </span><br><span class="line">          return arr</span><br><span class="line">        &#125;,</span><br><span class="line">        addClass: function(classes) &#123;</span><br><span class="line">          for (let key in classes) &#123;</span><br><span class="line">            var value = classes[key]</span><br><span class="line">            var methodName = value ? &apos;add&apos; : &apos;remove&apos;</span><br><span class="line">            node.classList[methodName](key)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后边这种方法就是jquery的思路。即将Node2改为jQuery。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">window.jQuery = function(nodeOrSelector) &#123;</span><br><span class="line">  let nodes = &#123;&#125;</span><br><span class="line">  if (typeof nodeOrSelector === &apos;string&apos;) &#123;</span><br><span class="line">    let temp = document.querySelectorAll(nodeOrSelector)</span><br><span class="line">    for (let i = 0; i &lt; temp.length; i++) &#123;</span><br><span class="line">      nodes[i] = temp[i]</span><br><span class="line">    &#125;</span><br><span class="line">      nodes.length = temp.length</span><br><span class="line">  &#125;  </span><br><span class="line">  else if (nodeOrSelector instanceof Node) &#123;</span><br><span class="line">    nodes = &#123;0: nodeOrSelector,length: 1&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  nodes.getSiblings = function() &#123;&#125;</span><br><span class="line">  nodes.addClass = function(classes) &#123;</span><br><span class="line">    classes.forEach((value) =&gt; &#123;</span><br><span class="line">      for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">        nodes[i].classList.add(value)      </span><br><span class="line">      &#125;      </span><br><span class="line">    &#125;) </span><br><span class="line">  &#125;</span><br><span class="line">  nodes.text = function (text) &#123;</span><br><span class="line">    if (text === undefined) &#123;</span><br><span class="line">      let texts = []</span><br><span class="line">      for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">        texts.push(nodes[i].textContent)</span><br><span class="line">      &#125;</span><br><span class="line">      return texts</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">        nodes[i].textContent = text</span><br><span class="line">      &#125;</span><br><span class="line">      return texts</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/10/jQuery/" data-id="cjkxghrlk000dewkw43piw7xz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CSS学习之Selectors、animation等" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/27/CSS学习之Selectors、animation等/" class="article-date">
  <time datetime="2018-07-27T07:13:08.000Z" itemprop="datePublished">2018-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/27/CSS学习之Selectors、animation等/">CSS学习之Selectors、animation等</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文主要是对于学习中遇到的新CSS属性知识的总结，包括选择器(Selectors)、动画(Animation)、光标(Cursor)、z-index，以便加深记忆了解。</p>
</blockquote>
<h1 id="Selectors"><a href="#Selectors" class="headerlink" title="Selectors"></a>Selectors</h1><p>CSS选择器规定了CSS规则会应用到哪些元素上。</p>
<h2 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h2><h3 id="类型（Type）选择器"><a href="#类型（Type）选择器" class="headerlink" title="类型（Type）选择器"></a>类型（Type）选择器</h3><p>这种基本选择器会匹配 <strong>所有给定元素名</strong> 的元素。也叫做标签/元素选择器，匹配 <strong>所有使用某个标签</strong> 的元素。<br><strong>语法：元素{样式声明}</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  background: #000;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，所有的div都会应用以上的CSS属性。</p>
<h3 id="类（Class）选择器"><a href="#类（Class）选择器" class="headerlink" title="类（Class）选择器"></a>类（Class）选择器</h3><p>这种选择器会基于 <strong>类属性的值</strong> 来选择元素。<br><strong>语法：.classname{样式声明}</strong>/ 等价于 <strong>[class~=类名] {样式声明 }</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.ruguo&#123;</span><br><span class="line">  background: #000;</span><br><span class="line">  border: 10px solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，所有的class=”ruguo”的元素（标签）都会应用.ruguo的CSS属性。<br>如果是div.ruguo{},则会应用与以下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;ruguo&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>即应用于class=”ruguo”的div标签。</p>
<h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><p>这种选择器会选择 <strong>所有id属性与之匹配</strong> 的元素。注：一个文档中的每一个id都应该是唯一的。<br><strong>语法：#idname</strong>/等价于[id=id属性] {样式声明 }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#liebiao&#123;</span><br><span class="line">    font-size: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，所有的id=”liebiao”的元素（标签）都会应用#liebiao的CSS属性。</p>
<h3 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h3><p>这个选择器会选择所有的节点。通常与一个名词空间配合使用，选择这个空间下的所有元素。<br>语法：*<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>页面内所有元素都会运用*的属性。</p>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>这个基本的选择器根据元素的属性来进行选择。<br>语法：</p>
<ol>
<li>E[att]：匹配所有具有att属性的E元素，不考虑它的值。例如resume中的[data-x]</li>
<li>E[att=val]：匹配所有att属性等于”val”的E元素。</li>
<li>E[att~=val]：匹配所有att属性具有多个空格分隔的值、其中一个值等于”val”的E元素。</li>
<li>E[att|=val]：匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以”val”开头的E元素，主要用于lang属性，比如”en”、”en-us”、”en-gb”等等<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p[title] &#123; color:#f00; &#125;</span><br><span class="line">div[class=error] &#123; color:#f00; &#125;</span><br><span class="line">td[headers~=col1] &#123; color:#f00; &#125;</span><br><span class="line">p[lang|=en] &#123; color:#f00; &#125;</span><br><span class="line">blockquote[class=quote][cite] &#123; color:#f00; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="多元素的组合选择器"><a href="#多元素的组合选择器" class="headerlink" title="多元素的组合选择器"></a>多元素的组合选择器</h2><h3 id="相邻选择器"><a href="#相邻选择器" class="headerlink" title="相邻选择器"></a>相邻选择器</h3><p>它只会匹配紧跟其前方元素的同胞（同级）元素.<br>语法：前方元素 + 目标元素 {样式声明 }<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;One&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Two&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Three&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">hr</span><br><span class="line">li + li &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用一个结合符只能选择两个相邻兄弟中的第二个元素。<br>上面这个选择器只会把列表中的第二个和第三个列表项变为红色。第一个列表项不受影响。</p>
<h3 id="通用兄弟选择器"><a href="#通用兄弟选择器" class="headerlink" title="通用兄弟选择器"></a>通用兄弟选择器</h3><p>在使用 ~ 连接两个元素时,它会匹配第二个元素,条件是它必须跟(不一定是紧跟)在第一个元素之后,且他们都有一个共同的父元素 。<br>语法：元素 ~ 元素 {样式声明 }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;This is not red.&lt;/span&gt;</span><br><span class="line">&lt;p&gt;Here is a paragraph.&lt;/p&gt;</span><br><span class="line">&lt;code&gt;Here is some code.&lt;/code&gt;</span><br><span class="line">&lt;span&gt;And here is a span.&lt;/span&gt;</span><br><span class="line">hr</span><br><span class="line">p ~ span &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个CSS属性只会让第二个span中的字体变为红色，其他不受影响。</p>
<h3 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h3><p>当使用  &gt; 选择符分隔两个元素时,它只会匹配那些作为第一个元素的直接后代(子元素)的第二元素. 与之相比, 当两个元素由 后代选择器 相连时, 它表示匹配存在的所有由第一个元素作为祖先元素(但不一定是父元素)的第二个元素, 无论它在 DOM 中”跳跃” 多少次。<br>语法：元素1 &gt; 元素2 {样式声明 }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;span&gt;Span 1. In the div.</span><br><span class="line">    &lt;span&gt;Span 2. In the span that&apos;s in the div.&lt;/span&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;span&gt;Span 3. Not in a div at all&lt;/span&gt;</span><br><span class="line">hr</span><br><span class="line">span &#123; background-color: white; &#125;</span><br><span class="line">div &gt; span &#123;</span><br><span class="line">  background-color: DodgerBlue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，div &gt; span中的属性只会让span1中的字体变为DodgerBlue，span2和span3不受影响。</p>
<h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p>当使用 ␣ 选择符 (这里代表一个空格,更确切的说是一个或多个的空白字符) 连接两个元素时使得该选择器可以只匹配那些由第一个元素作为祖先元素的所有第二个元素(后代元素) . 后代选择器与 子选择器 很相似, 但是后代选择器不需要相匹配元素之间要有严格的父子关系.<br>语法：元素1 元素2 {样式声明 }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;span&gt;Span 1.</span><br><span class="line">    &lt;span&gt;Span 2.&lt;/span&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;span&gt;Span 3.&lt;/span&gt;</span><br><span class="line">hr</span><br><span class="line">span &#123; background-color: white; &#125;</span><br><span class="line">div span &#123; background-color: DodgerBlue; &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上只要是span的后代元素都会应用div span的CSS样式。即span1和span2，span3为div的同级元素，一辈儿的。</p>
<h3 id="多元素选择器"><a href="#多元素选择器" class="headerlink" title="多元素选择器"></a>多元素选择器</h3><p>多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔<br>语法：元素1,元素2{样式声明}<br>元素1和元素2都匹配CSS样式。</p>
<h2 id="伪类及伪元素选择器"><a href="#伪类及伪元素选择器" class="headerlink" title="伪类及伪元素选择器"></a>伪类及伪元素选择器</h2><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><ol>
<li><p>::before<br>CSS中，::before 创建一个伪元素，其将成为匹配选中的元素的第一个子元素。常通过 content 属性来为一个元素添加修饰性的内容。此元素默认为行内元素。(在一个元素之前插入生成的内容)<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a::before &#123;</span><br><span class="line">  content: &quot;♥&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>::after<br>CSS伪元素::after用来创建一个伪元素，做为已选中元素的最后一个子元素。通常会配合content属性来为该元素添加装饰内容。这个虚拟元素默认是行内元素。(在一个元素之后插入生成的内容)</p>
</li>
<li>::first-line<br>::first-line CSS pseudo-element （CSS伪元素）在某 block-level element （块级元素）的第一行应用样式。第一行的长度取决于很多因素，包括元素宽度，文档宽度和文本的文字大小。(匹配一个元素的第一行)</li>
<li>::first-letter<br>CSS 伪元素 ::first-letter会选中某 block-level element（块级元素）第一行的第一个字母，并且文字所处的行之前没有其他内容如图片和内联的表格。(匹配一个元素的第一个字母)<br>其他伪元素(<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements</a>)<h3 id="伪类-1"><a href="#伪类-1" class="headerlink" title="伪类"></a>伪类</h3></li>
<li>:first-child<br>:first-child CSS伪类 代表了一组兄弟元素中的第一个元素。（匹配父元素的第一个子元素）</li>
<li>:link<br>:link伪类选择器是用来选中元素当中的链接。它将会选中所有尚未访问的链接，包括那些已经给定了其他伪类选择器的链接（例如:hover选择器，:active选择器，:visited选择器）。为了可以正确地渲染链接元素的样式，:link伪类选择器应当放在其他伪类选择器的前面，并且遵循LVHA的先后顺序，即：:link — :visited — :hover — :active。:focus伪类选择器常伴随在:hover伪类选择器左右，需要根据你想要实现的效果确定它们的顺序。</li>
<li>:visited<br>匹配所有已被点击的链接</li>
<li>:active<br>匹配鼠标已经其上按下、还没有释放的E元素</li>
<li>:hover<br>匹配鼠标悬停其上的E元素</li>
<li>:focus<br>匹配获得当前焦点的E元素</li>
<li>:lang(c)<br>匹配lang属性等于c的E元素<br>其他伪类:(<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes</a>)<br>阮一峰相关资料:(<a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2009/03/css_selectors.html</a>)<br>hr<h1 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h1>CSS animations 使得可以将从一个CSS样式配置转换到另一个CSS样式配置。动画包括两个部分:描述动画的样式规则(animation)和用于指定动画开始、结束以及中间点样式的关键帧(@keyframes)。<h2 id="Animation属性"><a href="#Animation属性" class="headerlink" title="Animation属性"></a>Animation属性</h2></li>
<li>animation-delay<br>设置延时，即从元素加载完成之后到动画序列开始执行的这段时间。<br>值：从动画样式应用到元素上到元素开始执行动画的时间差。该值可用单位为秒(s)和毫秒(ms)。如果未设置单位，定义无效。</li>
<li>animation-direction<br>设置动画在每次运行完后是反向运行还是重新回到开始位置重复运行。</li>
<li>animation-duration<br>设置动画一个周期的时长。</li>
<li>animation-iteration-count<br>设置动画重复次数， 可以指定infinite无限次重复动画</li>
<li>animation-name<br>指定由@keyframes描述的关键帧名称。</li>
<li>animation-play-state<br>允许暂停和恢复动画。</li>
<li>animation-timing-function<br>设置动画速度， 即通过建立加速度曲线，设置动画在关键帧之间是如何变化。</li>
<li>animation-fill-mode<br>指定动画执行前后如何为目标元素应用样式。<br>详细信息：(<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations/Using_CSS_animations" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations/Using_CSS_animations</a>)<br>hr<br>animation也是一个简写形式。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div:hover &#123;</span><br><span class="line">  animation: 1s 1s rainbow linear 3 forwards normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这是一个简写形式，可以分解成各个单独的属性.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div:hover &#123;</span><br><span class="line">  animation-name: rainbow;</span><br><span class="line">  animation-duration: 1s;</span><br><span class="line">  animation-timing-function: linear;</span><br><span class="line">  animation-delay: 1s;</span><br><span class="line">  animation-fill-mode:forwards;</span><br><span class="line">  animation-direction: normal;</span><br><span class="line">  animation-iteration-count: 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h2><p>keyframes关键字用来定义动画的各个状态，它的写法相当自由。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@keyframes rainbow &#123;</span><br><span class="line">  0% &#123; background: #c00 &#125;</span><br><span class="line">  50% &#123; background: orange &#125;</span><br><span class="line">  100% &#123; background: yellowgreen &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>0%可以用from代表，100%可以用to代表.<br>阮一峰相关资料：(<a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html</a>)</p>
<h1 id="Cursor"><a href="#Cursor" class="headerlink" title="Cursor"></a>Cursor</h1><p>Cursor属性定义鼠标指针悬浮在元素上方显示的鼠标光标。<br>取值：pointer、progress、wait等。<br>详细：(<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/cursor" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/cursor</a>)</p>
<h1 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h1><p>z-index 属性指定了一个具有定位属性的元素及其子代元素的 z-order。 当元素之间重叠的时候，z-order 决定哪一个元素覆盖在其余元素的上方显示。 通常来说 z-index 较大的元素会覆盖较小的一个。<br>对于一个已经定位的元素（即position属性值是非static的元素），z-index 属性指定：<br>元素在当前堆叠上下文中的堆叠层级。<br>元素是否创建一个新的本地堆叠上下文。</p>
<h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><p>auto<br>元素不会建立一个新的本地堆叠上下文。当前堆叠上下文中新生成的元素和父元素堆叠层级相同。</p>
<p><integer><br>整型数字是生成的元素在当前堆叠上下文中的堆叠层级。元素同时会创建一个堆叠层级为0的本地堆叠上下文。这意味着子元素的 z-indexes 不与元素外的其余元素的 z-indexes 进行对比。</integer></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/27/CSS学习之Selectors、animation等/" data-id="cjkxghriv0000ewkw8i8kceer" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-原型及原型链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/27/原型及原型链/" class="article-date">
  <time datetime="2018-07-27T02:41:46.000Z" itemprop="datePublished">2018-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/27/原型及原型链/">原型及原型链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>原型及原型链</p>
</blockquote>
<h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><p>首先新建一个对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> var obj = &#123;name: &apos;chenzhe&apos;&#125;</span><br><span class="line"> obj.valueOf()</span><br><span class="line"> &#123;name: &quot;chenzhe&quot;&#125;</span><br><span class="line"> name:&quot;chenzhe&quot;</span><br><span class="line">__proto__:Object</span><br></pre></td></tr></table></figure></p>
<h2 id="在通过valueOf-返回新对象obj的原始值时，发现：除了name属性外还有一个proto属性，为什么在没有赋予的情况下存在这个proto属性呢？"><a href="#在通过valueOf-返回新对象obj的原始值时，发现：除了name属性外还有一个proto属性，为什么在没有赋予的情况下存在这个proto属性呢？" class="headerlink" title="在通过valueOf()返回新对象obj的原始值时，发现：除了name属性外还有一个proto属性，为什么在没有赋予的情况下存在这个proto属性呢？"></a>在通过valueOf()返回新对象obj的原始值时，发现：除了name属性外还有一个<strong>proto</strong>属性，为什么在没有赋予的情况下存在这个<strong>proto</strong>属性呢？</h2><p>window的属性包括ECMAScript规定的属性和浏览器(Chrome、FireFox)私有的属性.<br>ECMAScript规定的包括Number()、String()、Boolean()、Object()等。浏览器私有的属性有alert、prompt、confirm、console等。<br>如果创建一个数值的数据，对于数值的数据类型来说，都存在toExponential()、toFixed()、toPrecision()等一些公有属性。在存入内存时，把多个数值的多个相同的属性分别保存在不同的内存中的话，就会造成内存的浪费。<br>相对简单的解决办法就是把这些公有的属性存在一个固定的内存prototype中，然后在数据的引用时用一个属性<strong>proto</strong>代替,这样在声明一个数据时都有一个<strong>proto</strong>属性指向prototype这个数据的公有的属性，避免内存的浪费。</p>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>原型可以理解为，每一个JavaScript对象在创建的时候都会关联它的公有属性的对象，这个具有公有属性的对象就是原型，每一个对象在创建时都会从它的原型’继承’属性。</p>
<h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>每一个对象在创建后都有一个属性<strong>proto</strong>，这个属性指向该对象的原型。</p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><h2 id="constructor，每个原型都有一个-constructor-属性指向关联的构造函数。"><a href="#constructor，每个原型都有一个-constructor-属性指向关联的构造函数。" class="headerlink" title="constructor，每个原型都有一个 constructor 属性指向关联的构造函数。"></a>constructor，每个原型都有一个 constructor 属性指向关联的构造函数。</h2><p>由此我们得到第结论：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var 对象=new 函数()</span><br><span class="line">对象.__proto__ === 函数.prototype</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;&#125;</span><br><span class="line">a === a.prototype.constructor</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/07/27/5b5a94db94443.png" alt=""><br><img src="https://i.loli.net/2018/07/27/5b5a95ee63603.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/27/原型及原型链/" data-id="cjkxghrld000cewkwxgcdyckd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Tween-缓动" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/26/Tween-缓动/" class="article-date">
  <time datetime="2018-07-26T13:18:22.000Z" itemprop="datePublished">2018-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/26/Tween-缓动/">Tween-缓动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Tween,好用的缓动工具。</p>
</blockquote>
<h1 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h1><p>Google搜索Tween或者直接进入github.com/tweenjs/tween.js。看到示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var box = document.createElement(&apos;div&apos;);</span><br><span class="line">box.style.setProperty(&apos;background-color&apos;, &apos;#008800&apos;);</span><br><span class="line">box.style.setProperty(&apos;width&apos;, &apos;100px&apos;);</span><br><span class="line">box.style.setProperty(&apos;height&apos;, &apos;100px&apos;);</span><br><span class="line">document.body.appendChild(box);</span><br><span class="line"></span><br><span class="line">// Setup the animation loop. 设置动画循环</span><br><span class="line">function animate(time) &#123;</span><br><span class="line">    requestAnimationFrame(animate);</span><br><span class="line">    TWEEN.update(time);</span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(animate);</span><br><span class="line"></span><br><span class="line">var coords = &#123; x: 0, y: 0 &#125;; // Start at (0, 0) 从0,0开始</span><br><span class="line">var tween = new TWEEN.Tween(coords) // Create a new tween that modifies &apos;coords&apos;. 创建一个修改“coords”的新补间。</span><br><span class="line">        .to(&#123; x: 300, y: 200 &#125;, 1000) // Move to (300, 200) in 1 second. 在1秒内移动到（300,200）。</span><br><span class="line">        .easing(TWEEN.Easing.Quadratic.Out) // Use an easing function to make the animation smooth. 使用缓动功能使动画流畅。</span><br><span class="line">        .onUpdate(function() &#123; // Called after tween.js updates &apos;coords&apos;. 在tween.js更新&apos;coords&apos;之后调用。</span><br><span class="line">            // Move &apos;box&apos; to the position described by &apos;coords&apos; with a CSS translation. 使用CSS翻译将&apos;box&apos;移动到&apos;coords&apos;描述的位置。</span><br><span class="line">            box.style.setProperty(&apos;transform&apos;, &apos;translate(&apos; + coords.x + &apos;px, &apos; + coords.y + &apos;px)&apos;);</span><br><span class="line">        &#125;)</span><br><span class="line">        .start(); // Start the tween immediately. 立即启动补间。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Installation(安装)</span><br><span class="line">Download the library and include it in your code:</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;js/Tween.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">You can also reference a CDN-hosted version in your code, thanks to cdnjs. For example:</span><br><span class="line">（您还可以在代码中引用CDN托管版本，这要归功于cdnjs。例如：）</span><br><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">See tween.js for more versions.</span><br></pre></td></tr></table></figure>
<p>实际使用就是Google搜索CDNJS，进入后搜索Tween，这即是通过引用CDN库来进行使用。使用范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/tween.js/17.2.0/Tween.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function animate(time) &#123;</span><br><span class="line">    requestAnimationFrame(animate);</span><br><span class="line">    TWEEN.update(time);</span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(animate);</span><br><span class="line"></span><br><span class="line">let currentTop = window.scrollY</span><br><span class="line">let targetTop = top - 80</span><br><span class="line">let s = targetTop - currentTop</span><br><span class="line">var coords = &#123;y: currentTop&#125;; </span><br><span class="line">var t = Math.abs((s/100)*300)</span><br><span class="line">if(t&gt;500)&#123;</span><br><span class="line">	t = 500</span><br><span class="line">&#125;</span><br><span class="line">var tween = new TWEEN.Tween(coords) </span><br><span class="line">.to(&#123;y: targetTop &#125;, t) </span><br><span class="line">.easing(TWEEN.Easing.Quadratic.In) </span><br><span class="line">.onUpdate(function() &#123; </span><br><span class="line">	window.scrollTo(0,coords.y)</span><br><span class="line">&#125;)</span><br><span class="line">.start();</span><br></pre></td></tr></table></figure></p>
<h1 id="新的API和CSS属性"><a href="#新的API和CSS属性" class="headerlink" title="新的API和CSS属性"></a>新的API和CSS属性</h1><h2 id="keyframes和animation"><a href="#keyframes和animation" class="headerlink" title="@keyframes和animation"></a>@keyframes和animation</h2><p>@keyframes 规则通过在动画序列中定义关键帧（或waypoints）的样式来控制CSS动画序列中的中间步骤。这比转换(transition)更能控制动画序列的中间步骤。<br>@keyframes:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@keyframes slidein &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    margin-left: 100%;</span><br><span class="line">    width: 300%;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  to &#123;</span><br><span class="line">    margin-left: 0%;</span><br><span class="line">    width: 100%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要使用关键帧, 先创建一个带名称的@keyframes规则，以便后续使用 animation-name 这个属性来将一个动画同其关键帧声明匹配。<br>每个@keyframes 规则包含多个关键帧，也就是一段样式块语句，每个关键帧有一个百分比值作为名称，代表在动画进行中，在哪个阶段触发这个帧所包含的样式。<br>您可以按任意顺序列出关键帧百分比；他们将按照其应该发生的顺序来处理。</p>
<ol>
<li>如果一个关键帧规则没有指定动画的开始或结束状态（也就是，0%/from 和100%/to，浏览器将使用元素的现有样式作为起始/结束状态。</li>
<li>如果多个关键帧使用同一个名称，以最后一次定义的为准。</li>
<li>如果一个关键帧中没有出现其他关键帧中的属性，那么这个属性将使用插值(不能使用插值的属性除外, 这些属性会被忽略掉)。</li>
<li>关键帧中出现的 !important 关键词将会被忽略,示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@keyframes important1 &#123;</span><br><span class="line">  from &#123; margin-top: 50px; &#125;</span><br><span class="line">  50%  &#123; margin-top: 150px !important; &#125; /* 忽略 */</span><br><span class="line">  to   &#123; margin-top: 100px; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/26/Tween-缓动/" data-id="cjkxghrkk0008ewkwvhfubfoy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS数据类型转换" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/23/JS数据类型转换/" class="article-date">
  <time datetime="2018-07-23T06:25:30.000Z" itemprop="datePublished">2018-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/23/JS数据类型转换/">JS数据类型转换</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文主要介绍JS中数据的类型转换。</p>
<h1 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h1><p>String()可以把任意类型的值转换为字符串。</p>
<h2 id="原始类型值"><a href="#原始类型值" class="headerlink" title="原始类型值"></a>原始类型值</h2><ol>
<li>数值：转换为相应的字符串；</li>
<li>字符串：转换后还是原来的值；</li>
<li>布尔值：true转为字符串’true’，false转为字符串’false’；</li>
<li>undefined：转为字符串’undefined’；</li>
<li>null：转为字符串’null’；<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2>Sting()方法的参数如果是对象，返回一个类型字符串；如果是一个数组，返回该数组的字符串形式；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String([1, 2, 3])</span><br><span class="line">&quot;1,2,3&quot;</span><br><span class="line">String(&#123;a: 1&#125;)</span><br><span class="line">&quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注：如果是数值和布尔类型的还可以通过number/boolean + ‘’或者’’ + number/boolean来进行转换；<br>window.String()也可以转换为字符串。</p>
<h1 id="转换为布尔"><a href="#转换为布尔" class="headerlink" title="转换为布尔"></a>转换为布尔</h1><p>Boolean()函数可以将任意类型的值转换为布尔。<br>除了undefined、null、0、NaN以及空字符串的转换结果为false，其他全都为true。<br>注： 也可通过!!()来进行转换。</p>
<h1 id="转换为数值"><a href="#转换为数值" class="headerlink" title="转换为数值"></a>转换为数值</h1><p>Number()函数可以将任意类型的值转换为数值。</p>
<h2 id="原始类型的值"><a href="#原始类型的值" class="headerlink" title="原始类型的值"></a>原始类型的值</h2><ol>
<li>数值：转换后还是原来的值；</li>
<li>字符串：如果可以转换为数值，则直接转换为数值；如果不能转换为数值，则直接返回NaN；空字符串转换为0；</li>
<li>布尔值： true转换为1，false转换为0；</li>
<li>undefined：转换为NaN；</li>
<li>null：转换为0；<br>注： 还可通过parseInt()和parseFloat()转换为Number；<br>‘1’ - 0和+ ‘-1’ 也可以转换为数值。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/23/JS数据类型转换/" data-id="cjkxghrkb0006ewkw1ssbu2an" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS数据" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/23/JS数据/" class="article-date">
  <time datetime="2018-07-23T03:01:56.000Z" itemprop="datePublished">2018-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/23/JS数据/">JS数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>JS语言的每一个值，都属于某一种数据类型。一共有七种数据类型：Number、String、null、undefined、Boolean、Object、Symbol.</p>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ol>
<li>Number: 数值即整数和小数；</li>
<li>String: 字符串即文本；</li>
<li>null: 表示空值，即此处的值为空；</li>
<li>undefined: 表示未定义，即目前没有定义，所以此处暂时没有任何值；</li>
<li>Boolean: 布尔值即表示真伪的两个特殊值，真(true)和伪(false);</li>
<li>Object: 对象，通常是三个原始类型的值的合成，可以看作是一个存放各种类型的容器；<br>数值、字符串、布尔值这三种类型是最基本的数据类型，所以称为JS的原始类型；而null和undefined是JS数据类型的两个特殊值；对象则称为合成类型，分为三个子类型object（狭义的对象）、数组（array）和函数（function）。<h2 id="如何确定一个值是什么数据类型？"><a href="#如何确定一个值是什么数据类型？" class="headerlink" title="如何确定一个值是什么数据类型？"></a>如何确定一个值是什么数据类型？</h2></li>
<li>typeof运算符</li>
<li>instanceof运算符</li>
<li>Object.prototype.toString方法</li>
</ol>
<hr>
<h1 id="详细了解各种数据类型"><a href="#详细了解各种数据类型" class="headerlink" title="详细了解各种数据类型"></a>详细了解各种数据类型</h1><h2 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h2><p>null和undefined都可以表示‘没有’，含义基本相似。<br>null表示空值，即该处的值现在为空。如果调用函数时，某个参数未设置任何值，这时传入null，表示该值为空；<br>undefinde表示‘未定义’，返回为undefined的有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//变量声明了，但没有赋值</span><br><span class="line">var i;</span><br><span class="line">i;//undefined</span><br><span class="line">//调用函数时应该提供的参数没有提供，该参数就等于undefined</span><br><span class="line">functionf(x)&#123;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">f()//undefined</span><br><span class="line">//对象没有赋值的属性</span><br><span class="line">var  o = new Object();</span><br><span class="line">o.p //undefined</span><br><span class="line">//函数没有返回值时，默认返回undefined</span><br><span class="line">function f()&#123;&#125;</span><br><span class="line">f()//undefined</span><br></pre></td></tr></table></figure></p>
<h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><p>布尔值只有true和false两个值。<br>如果JavaScript预期某个位置上是布尔值，会将该位置上现有的值自动转换为布尔值。转换规则是下面六个值转为false，其他值都是true：<br>undefined、null、false、0、NaN、’’、””、document.all。<br>注：’’和””都代表空字符，document.all不常用。<br>    详细查看 MDN falsy</p>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>整数和浮点数<br>在JavaScript中，所有数字都是以64为浮点数的形式储存的，整数也是如此。所以1与1.0是相同的代表同一个数。这就是说，在JavaScript的底层根本没有整数，都是以小数的形式即64位浮点数存在的。</li>
<li>数值精度<br>JavaScript浮点数的64个二进制，从最左边开始是这样组成的：<br>第1位，符号位，0代表正数，1代表负数；<br>第2-12位，指数部分；<br>第13-63位，小数部分；<br>符号代表了一个数的正负，指数部分决定了数的大小，小数部分决定了数值的精度。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/23/JS数据/" data-id="cjkxghrk70005ewkwbfuj023l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS怎么学？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/13/JS怎么学？/" class="article-date">
  <time datetime="2018-07-13T09:32:08.000Z" itemprop="datePublished">2018-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/13/JS怎么学？/">JS怎么学？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JS的学习方法"><a href="#JS的学习方法" class="headerlink" title="JS的学习方法"></a>JS的学习方法</h1><p>学习到了这个阶段，经历了小学、初中、高中和大学这些阶段，寥寥数十载，想来不应该是去思考这个问题，但又好像不知道这个问题的答案。最近接触新知识，也通过自己来试试新方法，总结旧的方法，看看学习的成果。<br>最初的学习方法就是背、写、用，现在看来是最有效的方法。过程中的总结、对比都是加强记忆的辅助方式。经常会遇到自己也不知道自己在干什么的情况，这是在过程中遇到的迷茫，但在总体中是正确的。写这篇博客，意在做一个开头，指定以后的学习思路，将新的知识通过博客整理出来，整理的过程也是自己记忆的过程，学习的过程。读起来太累，也不适合现在的情况。通过键盘的打字整理来促进自己进行思考，毕竟如果长时间不思考，也太没有意义。<br>如果说想熟练的运用和知道一个新的知识和工具，最简单的方式就是记住它，背会它，看看别人怎么使用，自己慢慢学会怎么使用。理解了你就会用了，但如果连最基本的记住和使用都不会，根本就理解不了。理解是一个很长很长的过程，或许某一天你发现一个小技巧，小知识点，就会把一切给串联起来理解了。所以说以前的先理解再使用的方法现在可能要调换一下。在JS的学习上，要先使用，知道一行一行的代码怎么写，各种概念都是什么，这个都不知道的话，就是天天听天书。<br>自己一定可以坚持下来，争取每天更新一篇JS系统学习知识点的博客。<br>博客将会是每天一项必须的内容，加油哦。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/13/JS怎么学？/" data-id="cjkxghrk20004ewkw6o0hr4l3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CSS居中" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/28/CSS居中/" class="article-date">
  <time datetime="2018-06-28T08:24:56.000Z" itemprop="datePublished">2018-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/28/CSS居中/">CSS居中</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><p>实现左右布局主要通过float: left; + clearfix 来实现的。即：<br>给子元素加float: left;<br>给父元素加clearfix;<br>其中<br>.clearfix::after{<br>    content: ‘’;<br>    display: block;<br>    clear: both;<br>}</p>
<h1 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h1><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><ol>
<li>学习后首先想到的水平居中的方法就只有width和margin的结合可以实现居中。<br>做常见的水平居中：给div定义一个宽度，然后配合margin的左右值为auto来实现效果；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>方法简单易懂，浏览器兼容强，但扩展性差，就是说你在不知道width的情况下很难进行。</p>
<ol start="2">
<li>在块级父元素中让行内元素居中，只需使用text-align: center;<br><code>text-align: center;</code><br>这种方法可以让inline/inline-blcok/inline-table/flex等类型的元素实现居中。<h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="块级元素的垂直居中"><a href="#块级元素的垂直居中" class="headerlink" title="块级元素的垂直居中"></a>块级元素的垂直居中</h3>如果说已知块级元素的高度：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">&#125; </span><br><span class="line">.child &#123;</span><br><span class="line">    position: absolute; </span><br><span class="line">    top: 50%; </span><br><span class="line">    height: 100px; </span><br><span class="line">    margin-top: -50px;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果说未知块级元素的高度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  height: 500px;</span><br><span class="line">  width: 500px;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">&#125;</span><br><span class="line">.child&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  transform: translateY(-50%);</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="行内元素的垂直居中"><a href="#行内元素的垂直居中" class="headerlink" title="行内元素的垂直居中"></a>行内元素的垂直居中</h3><ol>
<li><p>文字的垂直居中只需将行高与高度设置为相等就可以实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    height: 100px;</span><br><span class="line">    line-height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以通过给行内元素添加padding-top和padding-bottom来实现垂直居中。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h2><p>position：fixd；可以让banner相对于屏幕固定，不占文档流的高度，即脱离文档流；<br>脱离之后文档流会缩起来，解决方法是：width: 100%;<br>使用width: 100%;之后会出现bug，左右100%+padding&gt;父元素宽度<br>解决方法：左右边距变为0，这是宽度真的是100%，重新加一个div，即加给<br>topNavBar-inner,重新加之后，选择器和浮动都要重新更改；再给新加元素tipNavBar一个padding,因为这个padding是加在topNavBar-inner里面的，所以说宽度最多还是100%，不会超过父元素topNavBar的宽度。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/28/CSS居中/" data-id="cjkxghrji0001ewkw43lx5q91" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/15/JSON/">JSON</a>
          </li>
        
          <li>
            <a href="/2018/08/14/DOM事件/">DOM事件</a>
          </li>
        
          <li>
            <a href="/2018/08/10/jQuery/">jQuery</a>
          </li>
        
          <li>
            <a href="/2018/07/27/CSS学习之Selectors、animation等/">CSS学习之Selectors、animation等</a>
          </li>
        
          <li>
            <a href="/2018/07/27/原型及原型链/">原型及原型链</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Chen Zhe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>